<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Crypto.Noise.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Crypto-Noise-Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">noise-0.0.0.0: Usable security for the internet, Deux</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>aseipp@pobox.com</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Crypto.Noise.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction
</a><ul><li><a href="#g:2">Box API
</a></li><li><a href="#g:3"><code>network</code> API
</a></li><li><a href="#g:4"><code>io-streams</code> API
</a></li><li><a href="#g:5">Padding
</a></li><li><a href="#g:6">Initial message support
</a><ul><li><a href="#g:7">X509 support
</a></li></ul></li></ul></li><li><a href="#g:8">Differences from the standard
</a></li><li><a href="#g:9">Other notes
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Noise is a suite of cryptographic protocols similar in spirit to
 NaCl's <code>crypto_box</code>, or network solutions like TLS, but simpler,
 faster, with higher-security elliptic-curve cryptography, and
 stronger guarantees about deniability and identity hiding.
</p><p>This protocol has many favorable security and usability properties,
 including:
</p><dl><dt><code>Sender forward secrecy</code></dt><dd> After encryption of a Noise box, only the
 recipient can decrypt it (the sender cannot).
</dd><dt><code>Deniable</code></dt><dd> The recipient of a Noise box can authenticate the
 sender, but cannot produce digitally-signed evidence binding the
 sender to anything.
</dd><dt><code>Identity hiding</code></dt><dd> Noise boxes reveal no information about the
 sender or recipient to a 3rd-party observer.
</dd><dt><code>High speed</code></dt><dd> Noise usues high-speed curves and ciphers designed by
 Dan Bernstein.
</dd><dt><code>Padded</code></dt><dd> Noise ciphertext can be padded to avoid leaking
 plaintext lengths.
</dd><dt><code>Built on &quot;Encrypt-then-MAC&quot; authenticated encryption</code></dt><dd> Any
 tampering with ciphertext will cause the recipient to reject the
 ciphertext prior to decryption.
</dd></dl><p>Noise pipes are built on Noise boxes and designed for interactive
 communications, and in addition to the above, Noise pipes offer the
 following benefits:
</p><dl><dt><code>Full forward secrecy or <em>full key erasure</em></code></dt><dd> Compromise of any
 long-term private keys never compromises old pipes. But furthermore,
 compromise of an <em>active</em> endpoint in an ongoinng communication does
 not compromise prior ciphertexts either - a Noise pipe forgets its
 chain secrets upon every message.
</dd><dt><code>Resistance to key-compromise impersonation</code></dt><dd> Even with a
 compromised private key, the compromised party can still verify other
 parties' identities in a Noise pipe.
</dd><dt><code>Efficient, encrypted handshakes with short roundtrip</code></dt><dd> Handshakes
 allow clients and servers to communicate after only one round trip,
 offering room for validation checks or certificates.
</dd></dl><p>This package offers:
</p><dl><dt><code>A high-level box API</code></dt><dd> Boxes are created using the simple
   <code><code><a href="Crypto-Encrypt-Noise.html#t:seal">seal</a></code></code> and <code><code><a href="Crypto-Encrypt-Noise.html#t:open">open</a></code></code>
   primitives. Boxes are encrypted, authenticated, and optionally
   anonymous. Furthermore, boxes are <em>forward secret</em>: only the
   receiver (identified by the receiving public key) can open them.
</dd><dt><code>A simplistic networking API</code></dt><dd> Noise pipes can be utilized
   easily on top of TCP sockets using the
   <code><code><a href="Crypto-Network-Noise.html#t:connect">connect</a></code></code> and
   <code><code><a href="Crypto-Network-Noise.html#t:serve">serve</a></code></code> primitives. This makes it easy to
   write networking services with transparent encryption support,
   built on familiar <code><code><a href="Crypto-Network-Noise.html#t:send">send</a></code></code> and
   <code><code><a href="Crypto-Network-Noise.html#t:recv">recv</a></code></code> primitives.
</dd><dt><code>A high-level io-streams API</code></dt><dd> The networking API internally is
   built off a high-level API based on <code>io-streams</code>, which makes
   encrypting data over a pipe as easy as reading/writing to an
   <code><code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:InputStream">InputStream</a></code></code> or
   <code><code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:OutputStream">OutputStream</a></code></code>. This also integrates with the
   networking API, making it easy to layer in extra transformations
   (compression, a high level packet format, etc).
</dd><dt><code>X509 certificate support</code></dt><dd> This package makes it easy for noise
   pipes to automatically validate X509 certificates as part of the
   handshake. Parties can begin exchanging data after only one round
   trip. In this case, the certificate is offered, which is
   validated before continuing.
</dd></dl><p>For more information visit <a href="https://github.com/trevp/noise/wiki">https://github.com/trevp/noise/wiki</a>.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"></ul></div><div id="interface"><h1 id="g:1">Introduction
</h1><div class="doc"><p>The <code>noise</code> package defines two sets of APIs: boxes and pipes. Boxes
handle standalone messages, and pipes encrypt communication channels.
</p><p>To begin, a sender and a receiver must create a keypair:
</p><p><code>
sender</code>(senderPK, senderSK)       &lt;- <code><a href="Crypto-Noise-Key.html#t:createKeypair">createKeypair</a></code>
receiver<code>(receiverPK, receiverSK) &lt;- <code><a href="Crypto-Noise-Key.html#t:createKeypair">createKeypair</a></code>
</code>
</p><p>Send the public keys around, and keep the private keys safe.
</p></div><h2 id="g:2">Box API
</h2><div class="doc"><p>Boxes are created using <code><code><a href="Crypto-Encrypt-Noise.html#t:seal">seal</a></code></code>, and opened
using <code><code><a href="Crypto-Encrypt-Noise.html#t:open">open</a></code></code>:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>b &lt;- seal (Just sender) receiverPK 32 $ pack &quot;Hello world!&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>print $ open receiverSK (Just senderPK) b
</code></strong>Just &quot;Hello world!&quot;
</pre><p>When creating a box, you specify the sending keypair, the receiving
public key, the amount of random padding you want (to obscure the
plaintext length), and the message. To open it, you specify the secret
key of the receiving party, and the public key of the sender.
</p><p>Attempting to open a box from someone other than the sender will
result in failure.
</p><p>Senders may also be <em>anonymous</em>, where the sender does not specify a
long-term key pair:
</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>b &lt;- seal Nothing receiverPK 32 $ pack &quot;Hello world!&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>print $ open receiverSK Nothing b
</code></strong>Just &quot;Hello world!&quot;
</pre><p>In the above example, the sender of the box is anonymous without a
keypair, and attempting to use a value other than <code>Nothing</code> as the key
will error. When the sender is anonymous, they are only identified by
a short-term ephemeral key, which is used only once for the
corresponding box.
</p><p>Once you have encrypted a value using <code><code><a href="Crypto-Encrypt-Noise.html#t:seal">seal</a></code></code>,
it can only be decrypted by the receiving party with the secret
key. This property means that boxes are <em>forward secret</em>: once you are
done creating them and have 'forgotten' the message, you cannot
recover it. Furthermore, boxes are <em>deniable</em>: a recipient of a box
can authenticate the sender. But they cannot produce signed evidence
binding the sender to anything. Finally, boxes do not produce any
evidence of who created them or who the receiver is, and resist
tampering with a strong MAC.
</p></div><h2 id="g:3"><code>network</code> API
</h2><h2 id="g:4"><code>io-streams</code> API
</h2><h2 id="g:5">Padding
</h2><div class="doc"><p>All messages in a noise pipe may optionally be padded to help prevent
plaintext length analysis on the encrypted pipe. By default, boxes
offer no padding - while pipes offer a small amount of random
padding, but <em>only</em> in the initial negotiation phase!
</p><p>To control the amount of padding set in a Noise box, use the input
parameter to <code><code><a href="Crypto-Encrypt-Noise.html#t:seal">seal</a></code></code>:
</p><pre>
pad &lt;- generateRandomNumberBetween 0 512
b &lt;- <code><a href="Crypto-Encrypt-Noise.html#t:seal">seal</a></code> Nothing receiver pad msg
...
</pre><p>This will encrypt the box and pad it with a random amount of data
(between 0 and 512 bytes, assuming a good distribution for the number
generator).
</p><p>To pad the initial boxes that are exchanged in a Pipe handshake,
you can set the <code><code><a href="Crypto-Network-Noise.html#t:confPadding">confPadding</a></code></code> parameter of the
<code><code><a href="Crypto-Network-Noise.html#t:PipeConf">PipeConf</a></code></code>. For example, setting
<code><code><a href="Crypto-Network-Noise.html#t:confPadding">confPadding</a></code> = 32</code> will pad the initial
handshake message you send with 32 random bytes.
</p><p>Encrypting an active Noise pipe is a little more work. In essence, you
must write a function to transform an
<code><code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:OutputStream">OutputStream</a></code></code> of this type:
</p><pre>
f :: <code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:OutputStream">OutputStream</a></code> <code><a href="Crypto-Network-Noise.html#t:PipeMsg">PipeMsg</a></code> -&gt; IO (<code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:OutputStream">OutputStream</a></code> <code><a href="Data-ByteString.html#t:ByteString">ByteString</a></code>)
</pre><p>There is an alias for this type - <code><code><a href="Crypto-Network-Noise.html#t:PipeMsgPadder">PipeMsgPadder</a></code></code>.
</p><p>The type <code><code><a href="Crypto-Network-Noise.html#t:PipeMsg">PipeMsg</a></code></code> is a simple message type,
pairing a <code><code><a href="Data-ByteString.html#t:ByteString">ByteString</a></code></code> with an integer - the number
of bytes to pad the message containing that buffer. You can think of
<code><code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:OutputStream">OutputStream</a></code> <code><a href="Crypto-Network-Noise.html#t:PipeMsg">PipeMsg</a></code></code> as
being equivalent to <code><code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:OutputStream">OutputStream</a></code>
(<code><a href="Data-ByteString.html#t:ByteString">ByteString</a></code>, Int)</code>
</p><p>The simplest transformation is
<code><code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code></code>, which pads every message
with a constant number of random bytes. This is used internally by
default if you don't specify your own transformation:
</p><pre>
<code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code> :: Word32 -&gt; <code><a href="Crypto-Network-Noise.html#t:PipeMsgPadder">PipeMsgPadder</a></code>
<code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code> n inp = <code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:makeOutputStream">makeOutputStream</a></code> $ \v -&gt;
  case v of
    Nothing -&gt; <code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:write">write</a></code> Nothing inp
    Just x  -&gt; <code><a href="/home/a/.cabal/share/doc/x86_64-linux-ghc-7.6.3/io-streams-1.1.4.2/html/System-IO-Streams.html#t:write">write</a></code> (Just (<code><a href="Crypto-Network-Noise.html#t:PipeMsg">PipeMsg</a></code> x n)) inp
</pre><p>For example, <code><code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code> 0</code> is a routine
which will never pad any outgoing
messages.<code><code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code> 32</code> is a routine
which will pad every message with 32 random bytes.
</p><p>By default, a Noise pipe uses
<code><code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code> 0</code> internally when you do
not specify your own padding routine.
</p><p>In addition, there is also another routine provided -
<code><code><a href="Crypto-Network-Noise.html#t:randomPadStream">randomPadStream</a></code></code> - which will pad every
outgoing message with a randomly selected number of bytes (within the
specified range).
</p><p>Either end of a noise pipe can have their own unique padding routines
specified without problem.
</p><p>To specify the padding routine, simply specify it in the
<code><code><a href="Crypto-Network-Noise.html#t:confPadder">confPadder</a></code></code> of your configuration. For
example, to pad every message from the client with a random number of
bytes in the range of 0 to 32, and pad every message from the server
with 64 random bytes, you can write:
</p><pre>
let sconf = <code><a href="Crypto-Network-Noise.html#t:defaultPipeConfig">defaultPipeConfig</a></code>
              { <code><a href="Crypto-Network-Noise.html#t:confPadder">confPadder</a></code> = Just (<code><a href="Crypto-Network-Noise.html#t:constantPadStream">constantPadStream</a></code> 64)
              }

let cconf = <code><a href="Crypto-Network-Noise.html#t:defaultPipeConfig">defaultPipeConfig</a></code>
              { <code><a href="Crypto-Network-Noise.html#t:confPadder">confPadder</a></code> = Just (<code><a href="Crypto-Network-Noise.html#t:randomPadStream">randomPadStream</a></code> 0 32)
              }
</pre><p>Note that padding is, of course, not free: as the bytes are taken from
<code>/dev/urandom</code>, in some very unscientific benchmarks, a parameter
like <code>(<code><a href="Crypto-Network-Noise.html#t:randomPadStream">randomPadStream</a></code> 0 4096)</code> cut the speed
of encrypting/decrypting <code>/dev/zero</code> and writing it to <code><em>dev\</em>null</code>
by 50% (200MB/s vs 100MB/s), with the Linux kernel's internal
cryptographic routines dominating runtime profiles.
</p></div><h2 id="g:6">Initial message support
</h2><div class="doc"><p>Noise pipes have an advantage over TLS in that only one round trip is
needed to start sending data - as part of the handshake, the server
and client can exchange data inside boxes.
</p><p>By default, servers and clients are configured to send 16 bytes of
zeros in their boxes, and they both validate the boxes have zeros in
the handshake. This can be changed by updating
<code><code><a href="Crypto-Network-Noise.html#t:PipeConfig">PipeConfig</a></code></code> before connecting.
</p><p>This feature allows you to immediately exchange data (taking full
advantage of the early roundtrip for your application), or do more
exotic things like certificate validation (see below for X509
support).
</p><p>Using this support is easy. In the <code><code><a href="Crypto-Network-Noise.html#t:PipeConfig">PipeConfig</a></code></code>
for both parties, you can specify two fields:
</p><pre>
 1 - <code><a href="Crypto-Network-Noise.html#t:confInitialMsg">confInitialMsg</a></code>      :: Maybe (IO <code><a href="Data-ByteString.html#t:ByteString">ByteString</a></code>)
 2 - <code><a href="Crypto-Network-Noise.html#t:confInitialResponse">confInitialResponse</a></code> :: Maybe (<code><a href="Data-ByteString.html#t:ByteString">ByteString</a></code> -&gt; IO Bool)
</pre><p>These two fields specify the initial handshake procedure (in the
order they occur). By default, the handshake looks like:
</p><pre>
Step #1: Client ---- Ephemeral Key ---&gt; Server (BEGIN)

Step <a name="2: Client &lt;--- noise_box "></a>1  ---- Server (Initial server message)

Step <a name="3: Client ---- noise_box "></a>2  ---&gt; Server (Initial client message)

Step #4: Client &lt;---- ciphertext -----&gt; Server (Bidirectional communication)
</pre><p>The initial server message in step #2 is specified with
<code><code><a href="Crypto-Network-Noise.html#t:confInitialMsg">confInitialMsg</a></code></code> on the server end, and the
client checks if this is valid using
<code><code><a href="Crypto-Network-Noise.html#t:confInitialResponse">confInitialResponse</a></code></code>. If it is, the client
responds with the result of its own
<code><code><a href="Crypto-Network-Noise.html#t:confInitialMsg">confInitialMsg</a></code></code> in step #3, and the server
checks this message with its
<code><code><a href="Crypto-Network-Noise.html#t:confInitialResponse">confInitialResponse</a></code></code>. If this finishes, then
the connection is established in step #4 (see <a href="Crypto-Noise-Protocol.html">Crypto.Noise.Protocol</a>
for details).
</p><p>Note that even if these parameters are set to <code><code>Nothing</code></code>, validation
always takes place: if you <em>do not</em> specify any override, or use
<code><code>Nothing</code></code> explicitly, then the server uses the implicit default: a
payload of 16 zero bytes each way, with the validation confirming
this.
</p><p>This means that if you override one of the initial messages, you MUST
override the counterpart for the other party. This prevents clients
and servers from finishing the handshake if they're incorrectly
configured on either end. In other words, this is the default
operation if you don't specify your own overrides:
</p><pre>
<code><a href="Crypto-Network-Noise.html#t:confInitialMsg">confInitialMsg</a></code>      = Just $ return (<code><a href="Data-ByteString.html#t:replicate">replicate</a></code> 16 0x0)
<code><a href="Crypto-Network-Noise.html#t:confInitialResponse">confInitialResponse</a></code> = Just $ x -&gt; return (x == <code><a href="Data-ByteString.html#t:replicate">replicate</a></code> 16 0x0)
</pre></div><h3 id="g:7">X509 support
</h3><h1 id="g:8">Differences from the standard
</h1><div class="doc"><p>Currently, this package <em>mostly</em> implements the Noise specification
faithfully.
</p><p>The large exception is that we use Curve25519 instead of
Curve41417. Curve41417 offers a 200-bit security level, which is
really what Noise aims to offer (NaCl <code>crypto_box</code> routines similarly
only offer 128-bit security). As a result, keys are only 32 bytes as
opposed to 52 bytes.
</p><p>In the future, this protocol will use Curve41417 by default.
</p></div><h1 id="g:9">Other notes
</h1><div class="doc"><p>Here are some important things to note when using this protocol:
</p><dl><dt><code>You can't turn off the encryption</code></dt><dd> There is no way to disable
encryption. Furthermore, the primitives should be high-speed enough to
not negatively impact large workloads.
</dd><dt><code>No protection against traffic analysis by default</code></dt><dd> While the
initial boxes feature randomized padding by default, the outgoing
ciphertext is not padded in any way.. If you want to randomize your
traffic a bit, use the
<code><code><a href="Crypto-Network-Noise.html#t:randomPadStream">randomPadStream</a></code></code> transformer in your
configuration to automatically pad outgoing traffic. The underlying
random number generator is MWC seeded from <code>/dev/urandom</code>, so it
should be fast, and pick numbers in the specified range with a good
distribution.
</dd></dl></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>